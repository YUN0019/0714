# 搶票機器人 TO-DO 任務清單

## 可行性評估
### 高可行性（技術成熟，實現難度低）
- 自動登入模組（3.1）：使用 Puppeteer 或 Selenium 可輕鬆實現。
- 自動等待與刷新模組（3.2）：基於定時器與 HTTP 請求即可完成。
- Cookie 儲存與重用模組（3.8）：可利用現有的 Cookie 管理工具實現。
- 錯誤處理與日誌紀錄（5）：技術簡單，主要是設計與實作。

### 中等可行性（需進行技術調研與測試）
- 驗證碼辨識（OCR）模組（3.5）：Tesseract OCR 整合相對簡單，但準確率可能受限。
- 排隊處理模組（3.7）：需模擬平台的排隊邏輯，可能需要反向工程。
- Proxy / IP 切換設計（3.9）：需整合第三方 Proxy 服務，並處理 IP 封鎖風險。

### 低可行性（技術挑戰大，風險高）
- 自動選座模組（3.6）：需解析平台的座位圖結構，可能涉及大量 DOM 操作。
- 多平台支援（6.1）：不同平台的購票流程差異大，需針對性開發。

## 建議
- 優先完成高可行性模組，確保核心功能可用。
- 中等可行性模組需進行技術調研，確保穩定性。
- 低可行性模組可作為擴展功能，視資源與時間決定是否實現。

## 原始任務清單

## 1. 專案規劃與需求分析（1 週）
### 1.1 明確專案目標（0.5 週）
- [ ] 定義搶票機器人的核心功能
- [ ] 確定支援的購票平台（如 KKTIX、FamiTicket 等）
- [ ] 確定專案的技術堆疊（前端框架、後端框架、資料庫等）

### 1.2 使用者需求收集（0.5 週）
- [ ] 訪談目標使用者，收集需求
- [ ] 分析使用者購票流程與痛點
- [ ] 撰寫需求規格文件（SRS）

### 1.3 技術可行性與風險評估（1 週）
- [ ] 評估自動化工具（如 Puppeteer、Selenium）
- [ ] 評估驗證碼辨識技術（如 Tesseract OCR）
- [ ] 分析可能的風險（如平台封鎖、法律問題）

## 2. 系統設計（1.5 週）
### 2.1 模組架構設計（0.5 週）
- [ ] 前端：設計使用者介面（UI）框架
- [ ] 後端：設計 API 架構與模組分層
- [ ] 定義前後端通訊協議（如 RESTful API 或 WebSocket）

### 2.2 自動化策略擬定（0.5 週）
- [ ] 設計自動登入與驗證流程
- [ ] 設計自動刷新與排隊策略
- [ ] 設計多帳號與多 IP 切換策略

### 2.3 資料結構與設定檔設計（0.5 週）
- [ ] 設計資料庫結構（如用戶資料、購票記錄）
- [ ] 設計設定檔格式（如 JSON 或 YAML）
- [ ] 定義錯誤代碼與日誌格式

## 3. 功能模組開發（4 週）
### 3.1 自動登入模組（0.5 週）
#### 前端
- [ ] 設計登入頁面與輸入驗證
#### 後端
- [ ] 實作登入 API
- [ ] 支援多帳號管理

### 3.2 自動等待與刷新模組（0.5 週）
#### 前端
- [ ] 顯示等待進度條
- [ ] 提供手動刷新按鈕
#### 後端
- [ ] 實作自動刷新邏輯
- [ ] 優化伺服器請求頻率

### 3.3 自動選擇票價與張數模組（0.5 週）
#### 前端
- [ ] 設計票價與張數選擇介面
#### 後端
- [ ] 實作票價與張數選擇 API
- [ ] 驗證選擇的有效性

### 3.4 自動點擊送單模組（0.5 週）
#### 前端
- [ ] 設計送單按鈕與確認彈窗
#### 後端
- [ ] 實作送單 API
- [ ] 確保送單請求的穩定性

### 3.5 驗證碼辨識（OCR）模組（0.5 週）
#### 前端
- [ ] 提供驗證碼輸入框與圖片顯示
#### 後端
- [ ] 整合 Tesseract OCR 或其他服務
- [ ] 提供驗證碼辨識 API

### 3.6 自動選座模組（0.5 週）
#### 前端
- [ ] 設計座位圖顯示與選擇功能
#### 後端
- [ ] 實作座位選擇 API
- [ ] 優化座位分配邏輯

### 3.7 排隊處理模組（0.5 週）
#### 前端
- [ ] 顯示排隊進度與剩餘時間
#### 後端
- [ ] 實作排隊邏輯
- [ ] 優化排隊順序與優先級

### 3.8 Cookie 儲存與重用模組（0.5 週）
#### 前端
- [ ] 提供 Cookie 管理介面
#### 後端
- [ ] 實作 Cookie 儲存與加密
- [ ] 支援 Cookie 自動載入

### 3.9 Proxy / IP 切換設計（0.5 週）
#### 前端
- [ ] 提供 Proxy 設定介面
#### 後端
- [ ] 實作 Proxy 切換邏輯
- [ ] 整合第三方 Proxy 服務

## 4. 系統測試（2 週）
### 4.1 單元測試（1 週）
- [ ] 前端：測試各模組的 UI 與交互
- [ ] 後端：測試 API 的正確性與穩定性

### 4.2 整合測試（1 週）
- [ ] 測試前後端整合流程
- [ ] 模擬實際購票場景進行壓力測試

## 5. 錯誤處理與日誌紀錄（1 週）
### 5.1 設計 log 寫入格式（0.5 週）
- [ ] 定義日誌格式（如 JSON 或純文字）
- [ ] 設計日誌等級（如 INFO、ERROR）

### 5.2 錯誤處理與提示通知（0.5 週）
- [ ] 前端：顯示錯誤提示與重試按鈕
- [ ] 後端：實作錯誤捕捉與通知機制

## 6. 系統擴充與維護（1 週）
### 6.1 多平台支援（如 KKTIX）（0.5 週）
- [ ] 分析其他平台的購票流程
- [ ] 擴充現有模組以支援新平台

### 6.2 模組化與架構優化（0.5 週）
- [ ] 重構代碼以提高可維護性
- [ ] 優化系統性能與資源使用

## 使用的程式語言與 API
### 程式語言：
- **前端**：JavaScript/TypeScript（搭配框架如 React 或 Vue.js）
- **後端**：Python（使用 Flask 或 FastAPI）
- **資料庫**：MongoDB 或 PostgreSQL
- **自動化工具**：Selenium 或 Playwright（基於 Python）

### API：
- **驗證碼辨識**：Tesseract OCR（開源）或第三方 API（如 Google Vision API）
- **Proxy/IP 切換**：第三方 Proxy 服務（如 Bright Data 或 ProxyMesh）
- **日誌與錯誤追蹤**：Sentry 或 Logstash

## 可能遇到的問題與解決方法
### 驗證碼辨識準確率低：
- **問題**：驗證碼可能包含干擾線條或扭曲，導致辨識率低。
- **解決方法**：使用更高效的 OCR 模型（如深度學習模型），或考慮人工輔助驗證碼輸入。

### 平台封鎖與反爬蟲機制：
- **問題**：購票平台可能檢測到機器人行為並封鎖 IP 或帳號。
- **解決方法**：實現隨機化操作（如延遲、模擬人類行為），並使用 Proxy/IP 切換來分散風險。

### 排隊邏輯的反向工程：
- **問題**：平台的排隊邏輯可能加密或隱藏，難以模擬。
- **解決方法**：分析網路請求與回應，嘗試模擬排隊行為，或考慮手動排隊後自動化後續流程。

### 多平台支援的開發成本高：
- **問題**：不同平台的購票流程差異大，需針對性開發。
- **解決方法**：模組化設計，將通用邏輯抽象化，僅針對特定平台實現差異化邏輯。

### 法律與道德問題：
- **問題**：部分平台可能禁止使用自動化工具，可能涉及法律風險。
- **解決方法**：確認當地法律規範，並與平台協商或取得授權。

是否能排除問題
大部分技術問題可以通過以下方式排除：

技術調研：深入研究相關技術與工具，選擇最佳解決方案。
測試與優化：通過大量測試來提高系統穩定性與可靠性。
模組化設計：降低開發與維護成本，提升系統靈活性。
不過，法律與道德問題需謹慎處理，可能需要法律諮詢或與平台協商。